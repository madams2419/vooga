#Project Journal

##Time Review

I have no idea how many hours I spent on this project, and it's honestly a ridiculous question.  However, we started working on March 20th and continued to work until the morning of the demo, April 30th.  The project was really divided up into three sections for me.  For the first week, all we did was work on the design and overall construction of the project.  After that, I spent most of sprint 1 coding new features and combining them with everyone else's code.  Unlike previous projects though, I feel like I spent most of my time during sprint 2 refactoring code to make up for some of the poor implementation decisions that compromised the overall design of our project (complicated implementations of some features leaked complexity into other features and made the code unnecessarily dependent, so I fixed it).  My own code management follows a typical implement and debug pattern.  I don't tend to make very many commits, and often I make sure a feature works entirely before committing.  On top of that, a number of commits usually made up a single pull request.  However, my development process still followed a basic implement, commit, debug, commit, push patten.  The easiest task was writing the GUI/launcher for the program.  Not only was it fairly simple to do, everyone seemed to like it which was great.  As rewarding as that was though, it does not compare to completing one of the harder things I had to do during the project, re-factor the majority of the game engine.  After the first sprint, our code had innumerable unnecessary which I went through and removed all in one fell swoop.  It was challenging both in terms of time commitment and amount of code but also in terms of figuring out how exactly to re-implement the pieces to reduce dependencies without losing any functionality or communication between the parts.  I feel like both tasks were a good use of my time.

##Teamwork

At the beginning of the first sprint during the design week, the team met a handful of times totaling to about 20-30 hours spent designing.  In addition to that time, we also met for another approximately 10-15 hours at the beginning of sprint 2 to decide how to move forward with re-factoring our code and what to implement next.  Natalie, Daniel, Andrew, Jeannie, and Mengchao all worked on building the authoring environment while I, Mike, Michael, Emre, Tony, Yangcheng, and Kevin all worked on the engine side.  After sprint 1, Michael and Jeannie broke off to create the social center.  I can't speak to responsibilities within the authoring group, but Mike worked on the physics engine, Michael did the collision engine, Tony created objectives and scrolling, Yangcheng did controls, Emre and Kevin finished the sprites, and I mostly re-factored code so that it would work with other people's code and to ensure good design.  My most significant re-factorizations were in controls, collisions, and sprites.  I made massive changes to the physics engine but do to a lack of time we reverted to the old code for functionality.  I think that Tony deserves special praise for his contribution since he was definitely the most committed member of our team and just generally got things done efficiently and with good design.  The team overall communicated very well.  With the exception of some build issues at the end of the first sprint, everyone made sure their code worked with existing code (we determined the build issue was a merge conflict in the classpath).  The plan held up pretty well in terms of roles and responsibilities, and everyone delivered on their part of the project.  Aside from that, there wasn't much of a plan which is why we ran into some issues at the end of sprint 1 / beginning of sprint 2 integrating everyone's code.  Features leaked and we lost a lot of extensibility and customize-ability for the sake of minor functionality.  This ultimately limited us during sprint 2 from getting to some of the more complicated extensions since we had to spend a significant amount of time re-writing code.

##Issues

After reading through my commit messages, I would say that they do indeed summarize my contribution to the project.  Some of the commit messages seem to slightly trivialize the content and work that went into a particular commit.  I personally worked on 7 of the existing issues that we created, although I feel like this number slightly under represents my actual contribution to the project.  An issue that I solely worked on from start to finish was the front end gui allowing users to choose to design or play a game and which game to play.  Although important design choices tend to be less prevalent in the front end, I had to choose how to break up the responsibilities of launching our program to avoid a mega-class with too much unrelated functionality.  Initially, I didn't have to do collaborate really at all with my teammates on this issue since we had already decided to launch both programs from one launcher.  However, after I had closed the issue, I had to essentially rewrite one class in order to add a new goal.  We also needed to launch a social center, so I added a third section to the screen to accommodate their feature.

##Conclusions

The group definitely under estimate the size of the project.  But I'd say that we spent as much time working as we could, and our under estimation of time was more of an over estimation of ability to complete a lot of complicated features.  I'd say if anything that I took too much responsibility and at times infringed on other people's work when I should have trusted their implementation.  By the same token, I'm also glad that I stepped in to fix some issues.  I definitely tried to keep my team well informed and was very active in  our group chat, although it is really my team's call whether I actually communicated well.  The physics engine underwent the most editing since it has the most complicated implementation.  Controlling leaking and just generally implementing such a delicate entity within our code took a lot of patience and editing.  To be a better designer, I need to really focus solely on one component and its public api at a time and consider what the component should be giving to the rest of the program as opposed to what the rest of the program should be taking from the component.  To be a better teammate, I need to put more faith in other's ability to deliver on responsibilities and to develop quality code.  If I could improve one part of the project now, I'd definitely want to re-factor the physics engine to allow for greater extensibility and to create a less complex public api.

#Design Review

##Status

Hypothetically, all of the code has the same naming and stylistic conventions since we discussed both during design week.  However, in practice, it is very likely that a number of minute differences appear throughout the code depending on the author.  The code is fairly readable; some sections of the physics engine should be more heavily commented to illuminate which physical function they fulfill.  However, on the whole, variable and method names tend to do a solid job describing what happens and when.  The code for one update frame follows a pretty easily traced path from class to class.  We implemented an intricate observer observable scheme between sprites, their physics objects, and their animations in which both physics objects observed each other and the sprite.  Thus, some `notifyObservers()` calls are tricky to see.  The goal of the project and each component's design was to allow for easy extension of features and the seamless addition of new features.  Each component interfaces very simply with the rest of the program and relies only on the interface of the other components as opposed to their implementations.  That way different implementations can be switched in and out at the game author's leisure and the whole flow of the engine can be changed to add a new feature without seriously compromising any existing ones.

First I will review the `PhysicsObject` class in the physics package.  I chose to review this class because the design of the code is fairly lacking.  Although the `PhysicsObject` accomplishes quite a bit functionally, its public api is too complicated and thus leaks unnecessary implementation details of the physics engine into other parts of the program.  Furthermore, all of the functionality is implemented in one class even though there are clear divisions (position, velocity, acceleration, â€¦) which could all be put in separate classes to maximize extensibility and re-usability.

Second, I like the collision detector package.  Collision detectors have a simple interface achieved using the `ICollisionDetector` interface.  They also utilize the composite pattern so that precise and expensive operations like pixel perfect detection can be optimize by simpler and faster detection methods combined into one single detector.  My only suggestion would be to make collision detection more independent from sprites.  Although the current dependency is minimal, in order for `ICollisionDetector`s to be used in another program, they must solely rely on `ImageView`s so that the other programs don't have to unnecessarily create a `Sprite` class.

Lastly, I like the single `Sprite` class.  A sprite, in reality, is really a very simple thing.  It's just a physical object tied to a series of images.  Thus, there is really no need for multiple types of sprites.  What sets different types of sprites apart is the types of objects that go into its parameters.  For example, a player sprite differs from a platform sprite in a few ways.  The animation has multiple states with rotating images instead of just a single static image.  The `PhysicsObject` of a player allows for diverse and realistic physical properties while a platform really just needs a location.  And finally, a player sprite has controls so that the user can interact with that sprite while a platform does not.  So by inputing the right components into a generic sprite and changing the controls, a single, generic `Sprite` class can cover a multitude of different types of sprites and behaviors.  The one suggestion I have is to increase the possible behaviors of a `Sprite` so that there are more available options to the game designer.  The Sprite class, assuming the user also borrowed the coupled functional interfaces (IAction, IBehavior, â€¦), would work just fine in any other program as it stands.

##Design

A game itself is divided into several sections: objectives, collisions, controls, physics, and sprites.  Objectives, collisions, and controls all have the ability to perform behaviors given a certain event which triggers method calls with mostly sprites.  For objectives, this occurs when an objective is either completed or failed.  Collisions trigger behaviors via a resolver if the detector returns true that there was indeed a collision.  Controls trigger behavior asynchronously when a key is pressed or released using javaFX listeners or alternatively, synchronously every frame while a key is pressed.  Internally, there are a handful of different types of objectives (time, condition, â€¦), all of which extend a common super class so that they are easily interfaced with the rest of the program.  Collisions are handled by a `CollisionManager` which checks every collision of interest.  Each collision contains a detector and a resolver.  If the detector returns true, then the resolver triggers a behavior somewhere else in the program.  Controls also use a manager class which channels javaFX `InputEvents` to the correct map.  If it's a key event, then the control map fetches specific behavior depending on the pressed status of the key.

Sprites and physics are also very closely linked.  Sprites contain an `Animation` and a `PhysicsObject`.  The `PhysicsObject` handles resolving physical collisions and the general movement of a sprite.  The sprite itself does not know its position, so this information is passed directly to `Animation` via an observer observable pattern.  Sprite is able to trigger changing the image via a user defined `String` which alerts `Animation` and `PhysicsObject` via observer observable as well to update the image displayed and the hitbox used for collision resolution.

To represent a game, an object from each class needs to be instantiated and put into a `VoogaGame` object which is what actually runs using a javaFX `Timeline` object.  The parameters for each of the components of a `VoogaGame` are read in from a single xml file located in the game_files directory and chosen by the user.  The xml files details all of the possible images of the sprite, all of the collisions to track, the shape of each object's hitboxes, and everything else needed at any point during the game.

One of the major focuses of our design was to allow the designer of a game to be very specific about which features they wanted to use and where.  For instance, a designer may choose to use very precise collision detection, but very imprecise collision resolution or a highly simplified physics object.  Thus, each component of the program needed to be self-contained and easily interfaced in a simple and common way such that the implementation details of a complex method or class don't affect the implementation of another section of the program.  For the most part, we achieved doing this.  However, the physics engine resulted in a compromise of this goal in order to attain a reasonable level of functionality.

One of the key features of our program is the objective.  All that is needed to implement objectives is contained in the objective package with some auxiliary classes contained in the behaviors package.  The entirety of the objective class is closed, but it could potentially be open to extension if a future programmer wanted to add a more complex objective completion detection system.  As it stands, the objective can either be completed or failed, triggering different behaviors.  Completion and failure both can be set by an outside object via and `IAction` or can transition from the active state if a condition is evaluated as true.  Because of this implementation and the openness of conditions, objectives can be highly versatile and don't really need to be extended and are hardly limited.

Another key feature to scrolling platformer games is the ability to scroll.  This feature is entirely implemented within the scrolling package.  Scrolling is broken up into three responsibilities with good design.  There is the scroller itself, which can either be animated or just a jolted immediate transition.  There is the scroll focus, which determines when scrolling actually needs to happen.  This can either occur whenever a movement occurs or when a tracked character exits the dead zone scroll box.  Finally, there is the tracker itself which can trigger a scroll calculation on a number of different events including a mini-map, `MouseEvents`, or character movement.  The only real issue with scrolling is that the complexity of some parts of the implementation bleed into levels and games making it challenging to make the scroll type customizable to the user.  However, as the vast number of current implementations and the ability to choose any combination of scroller, scroll focus, and tracker shows both how flexible scrolling is and how easily it could be extended in a similar fashion.

##Alternate Designs

The original design stood up fairly well to our extensions.  Granted, our extensions were chosen partially based on what would be reasonably easy to implement given the current state of our design.  Because of this, our original api stayed fairly similar throughout the project.  As the classes became more and more complicated, especially sprite, the physics engine, and animation, the api's for those classes also increased in complexity.

The first design decision we had to make involved how to communicate information between the authoring environment and the game engine.  We had two options.  The first design completely separated the two programs so that the authoring environment used its own classes and wrote an xml file manually that the game engine then used to construct its own distinct objects.  On the one hand, this keeps both parts of the program very separate and makes switching engines and authoring environments very easy.  However, it also leads to some repeated code structure since each part of the program needs parallel classes to hold the game.  The alternative was to use a shared set of classes that were interfaced in two ways.  One interface allowed the authoring environment to set up the variables and place the objects.  The other interface allowed the game engine to actually use those objects to run a game.  This method reduced the complexity of writing out the game since we could just use xstream.  Additionally, it minimized overlapping classes and code since the structure was shared by both halves.  The problem though was that this technique introduced a high level of dependency between authoring and running which ultimately led us to choose the first option.

Another design choice we made involved the `Sprite` hierarchy.  One option was to use a hierarchy of classes so that players and platforms would be distinct types of objects.  This made sprite construction in the authoring environment very easy and highly intuitive.  However, it also burdened us with an unnecessary level of complexity and a lot of unused code.  The other option fixed this by only having a single `Sprite` class and using the components of different types of sprites to distinguish there behaviors.  I prefer using only one class since we could feasibly have set up default options to allow the designer of a game to quickly construct cookie cutter sprite types.  That way, we would have both of the advantages and neither disadvantage.

The last design choice that I will discuss concerned the responsibilities of objectives and levels.  The initial thought was that each level should point to the next level in a linked list sort of construction.  This seemed like the intuitive way to navigate from level to level with good design.  However, we quickly thought of the scenario where there are multiple ways to leave a level.  In this case, it would be almost impossible to determine from the level where to go next.  To counteract this, we added switching levels as an action of the game similar to a sprite jumping or moving.  That way a collision or an objective could easily trigger going to the next level.  Thus, the completion of one objective (i.e. going down a pipe) would take you to one level, but the completion of another (i.e. reaching the end of the level) would take you to an entirely different one.  Functionality wise, this solution is better without sacrificing any design quality and so this is my preferred solution.

The best features of the current design are the use of the composite pattern for collision detection and resolution since they allow for each aspect of collisions to be very powerful and complicated the the game designer's leisure.  Another really good feature is the use of `IAction`, `IActor`, and the behavior hierarchy since they allow for easily defining behavior on a collision or the completion of an objective in a safe and non-compromising way such as reflection.  The two most important remaining issues are also easily pointed out.  The physics engine still leaks its complexity into other parts of the program, mainly the game builder and the collision detector/resolver.  The second issue is the way that we track collisions.  As of now, we keep a list of every collision that has a behavior and we check those two sprites on every frame.  Thus complicated levels with lots of sprites and collisions become very slow.  This really limits our ability to implement projectiles since all of those sprites have to exist before they are ever fired, all of the relevant collisions will be checked before the projectile is active and after the projectile has expired.

#Code Masterpiece

To start, I will note that all of the code in this branch is actually taken from an old commit before our physics engine changed.  I intended to just copy the relevant physics engine code back into master, but since the physics engine is so directly tied to collisions and hitboxes, I found it easier to simply revert to the commit of interest so that you could see what I define as well designed code without having to spend an unreasonable amount of time relatively.  As a result of this, a number of features that we implemented after do not yet work or aren't even incorporated, so actually running the game is much different from our final version.  That being said, it does still work so feel free to run it to verify that the well designed physics engine I'm trying to describe does indeed work, just without some aspects like friction which were implemented after the group decided to switch to the another approach in order to attain functionality.  I labeled a large number of files as part of my masterpiece.  These are the files whose design and implementation depend directly on the physics engine and thus should be looked at as part of determining good design.  All other files should be disregarded since they have drastically changed since this commit was first made.

The key difference between my code masterpiece and the existing code is the inclusion of the hitbox package which serves as a connection between the physics engine and the collision engine.  Besides using the composite pattern to allow for multiple hitboxes to behave as one, hitboxes can also take on complex polygon shapes allowing the designer of a game to precisely outline their characters.  Hitboxes are used by the collision engine for both detection and resolution.  Detection is very simple, but the `HitboxResolver` allows for very powerful and precise collision resolution.  In the authoring environment when definig collisions and their behaviors, the designer can prioritize the collision of certain hitbox pairs before others to trigger specific behavior depending on how the two sprites collides.  This allows for Mario to die when he hits a goomba from the side but to kill the goomba when he hits them from the top.  Additionally, because of the composite pattern used for resolvers, there can be a general behavior for a collision regardless of orientation by coupling a `SimpleResolver` with a `HitboxResolver`.  Collisions can also be resolved physically using a `PhysicalResolver` which directs the `PhysicsEngine` to calculate the new parameters of the collided objects.

This brings us to the physics package where good design is most highlighted.  The physics is broken up into two aspects, physics objects and physics engines.  The engines handle collision resolution between two physics objects as well as any global forces or accelerations.  Too implement a new physics engine, the programmer only has to write a new class which extends `PhysicsEngine` and override the public methods.  The `ComplexPhysicsEngine` is an example of this and adds drag forces as an additional global force.

Physics objects are equally extensible.  The current implementation has all of the functionality of a physics object in one class, but my code masterpiece breaks this up into an inheritance chain.  Thus, position is handled in one class, velocity in another, acceleration in a third, and finally mass and force in the `SimplePhysicsEngine`.  Not only does separate responsibilities among multiple classes, it also makes the design of physics objects more extensible.  If a future programmer wanted to implement a physics object with only velocity, they could simply extend the `MovingPhysicsObject` class instead of having to entirely rewrite all of the behavior already implemented to handle position and velocity.  In this way, physics objects become highly open for diverse extension and closed to modification.  The `ComplexPhysicsObject` is an example of this which incorporates `Material` to allow for more complex calculation of mass with density and more detailed resolution of physical collisions using restitution.
