#Project Journal

##Time Review

I have no idea how many hours I spent on this project, and it's honestly a ridiculous question.  However, we started working on March 20th and continued to work until the morning of the demo, April 30th.  The project was really divided up into three sections for me.  For the first week, all we did was work on the design and overall construction of the project.  After that, I spent most of sprint 1 coding new features and combining them with everyone else's code.  Unlike previous projects though, I feel like I spent most of my time during sprint 2 refactoring code to make up for some of the poor implementation decisions that compromised the overall design of our project (complicated implementations of some features leaked complexity into other features and made the code unnecessarily dependent, so I fixed it).  My own code management follows a typical implement and debug pattern.  I don't tend to make very many commits, and often I make sure a feature works entirely before committing.  On top of that, a number of commits usually made up a single pull request.  However, my development process still followed a basic implement, commit, debug, commit, push patten.  The easiest task was writing the GUI/launcher for the program.  Not only was it fairly simple to do, everyone seemed to like it which was great.  As rewarding as that was though, it does not compare to completing one of the harder things I had to do during the project, re-factor the majority of the game engine.  After the first sprint, our code had innumerable unnecessary which I went through and removed all in one fell swoop.  It was challenging both in terms of time commitment and amount of code but also in terms of figuring out how exactly to re-implement the pieces to reduce dependencies without losing any functionality or communication between the parts.  I feel like both tasks were a good use of my time.

##Teamwork

At the beginning of the first sprint during the design week, the team met a handful of times totaling to about 20-30 hours spent designing.  In addition to that time, we also met for another approximately 10-15 hours at the beginning of sprint 2 to decide how to move forward with re-factoring our code and what to implement next.  Natalie, Daniel, Andrew, Jeannie, and Mengchao all worked on building the authoring environment while I, Mike, Michael, Emre, Tony, Yangcheng, and Kevin all worked on the engine side.  After sprint 1, Michael and Jeannie broke off to create the social center.  I can't speak to responsibilities within the authoring group, but Mike worked on the physics engine, Michael did the collision engine, Tony created objectives and scrolling, Yangcheng did controls, Emre and Kevin finished the sprites, and I mostly re-factored code so that it would work with other people's code and to ensure good design.  My most significant re-factorizations were in controls, collisions, and sprites.  I made massive changes to the physics engine but do to a lack of time we reverted to the old code for functionality.  I think that Tony deserves special praise for his contribution since he was definitely the most committed member of our team and just generally got things done efficiently and with good design.  The team overall communicated very well.  With the exception of some build issues at the end of the first sprint, everyone made sure their code worked with existing code (we determined the build issue was a merge conflict in the classpath).  The plan held up pretty well in terms of roles and responsibilities, and everyone delivered on their part of the project.  Aside from that, there wasn't much of a plan which is why we ran into some issues at the end of sprint 1 / beginning of sprint 2 integrating everyone's code.  Features leaked and we lost a lot of extensibility and customize-ability for the sake of minor functionality.  This ultimately limited us during sprint 2 from getting to some of the more complicated extensions since we had to spend a significant amount of time re-writing code.

##Issues

After reading through my commit messages, I would say that they do indeed summarize my contribution to the project.  Some of the commit messages seem to slightly trivialize the content and work that went into a particular commit.  I personally worked on 7 of the existing issues that we created, although I feel like this number slightly under represents my actual contribution to the project.  An issue that I solely worked on from start to finish was the front end gui allowing users to choose to design or play a game and which game to play.  Although important design choices tend to be less prevalent in the front end, I had to choose how to break up the responsibilities of launching our program to avoid a mega-class with too much unrelated functionality.  Initially, I didn't have to do collaborate really at all with my teammates on this issue since we had already decided to launch both programs from one launcher.  However, after I had closed the issue, I had to essentially rewrite one class in order to add a new goal.  We also needed to launch a social center, so I added a third section to the screen to accommodate their feature.

##Conclusions

The group definitely under estimate the size of the project.  But I'd say that we spent as much time working as we could, and our under estimation of time was more of an over estimation of ability to complete a lot of complicated features.  I'd say if anything that I took too much responsibility and at times infringed on other people's work when I should have trusted their implementation.  By the same token, I'm also glad that I stepped in to fix some issues.  I definitely tried to keep my team well informed and was very active in  our group chat, although it is really my team's call whether I actually communicated well.  The physics engine underwent the most editing since it has the most complicated implementation.  Controlling leaking and just generally implementing such a delicate entity within our code took a lot of patience and editing.  To be a better designer, I need to really focus solely on one component and its public api at a time and consider what the component should be giving to the rest of the program as opposed to what the rest of the program should be taking from the component.  To be a better teammate, I need to put more faith in other's ability to deliver on responsibilities and to develop quality code.  If I could improve one part of the project now, I'd definitely want to re-factor the physics engine to allow for greater extensibility and to create a less complex public api.

#Code Masterpiece

To start, I will note that all of the code in this branch is actually taken from an old commit before our physics engine changed.  I intended to just copy the relevant physics engine code back into master, but since the physics engine is so directly tied to collisions and hitboxes, I found it easier to simply revert to the commit of interest so that you could see what I define as well designed code without having to spend an unreasonable amount of time relatively.  As a result of this, a number of features that we implemented after do not yet work or aren't even incorporated, so actually running the game is much different from our final version.  That being said, it does still work so feel free to run it to verify that the well designed physics engine I'm trying to describe does indeed work, just without some aspects like friction which were implemented after the group decided to switch to the another approach in order to attain functionality.  I labeled a large number of files as part of my masterpiece.  These are the files whose design and implementation depend directly on the physics engine and thus should be looked at as part of determining good design.  All other files should be disregarded since they have drastically changed since this commit was first made.

The key difference between my code masterpiece and the existing code is the inclusion of the hitbox package which serves as a connection between the physics engine and the collision engine.  Besides using the composite pattern to allow for multiple hitboxes to behave as one, hitboxes can also take on complex polygon shapes allowing the designer of a game to precisely outline their characters.  Hitboxes are used by the collision engine for both detection and resolution.  Detection is very simple, but the `HitboxResolver` allows for very powerful and precise collision resolution.  In the authoring environment when definig collisions and their behaviors, the designer can prioritize the collision of certain hitbox pairs before others to trigger specific behavior depending on how the two sprites collides.  This allows for Mario to die when he hits a goomba from the side but to kill the goomba when he hits them from the top.  Additionally, because of the composite pattern used for resolvers, there can be a general behavior for a collision regardless of orientation by coupling a `SimpleResolver` with a `HitboxResolver`.  Collisions can also be resolved physically using a `PhysicalResolver` which directs the `PhysicsEngine` to calculate the new parameters of the collided objects.

This brings us to the physics package where good design is most highlighted.  The physics is broken up into two aspects, physics objects and physics engines.  The engines handle collision resolution between two physics objects as well as any global forces or accelerations.  Too implement a new physics engine, the programmer only has to write a new class which extends `PhysicsEngine` and override the public methods.  The `ComplexPhysicsEngine` is an example of this and adds drag forces as an additional global force.

Physics objects are equally extensible.  The current implementation has all of the functionality of a physics object in one class, but my code masterpiece breaks this up into an inheritance chain.  Thus, position is handled in one class, velocity in another, acceleration in a third, and finally mass and force in the `SimplePhysicsEngine`.  Not only does separate responsibilities among multiple classes, it also makes the design of physics objects more extensible.  If a future programmer wanted to implement a physics object with only velocity, they could simply extend the `MovingPhysicsObject` class instead of having to entirely rewrite all of the behavior already implemented to handle position and velocity.  In this way, physics objects become highly open for diverse extension and closed to modification.  The `ComplexPhysicsObject` is an example of this which incorporates `Material` to allow for more complex calculation of mass with density and more detailed resolution of physical collisions using restitution.
